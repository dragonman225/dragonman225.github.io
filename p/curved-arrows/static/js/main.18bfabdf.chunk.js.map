{"version":3,"sources":["curved-arrows/utils.ts","Arrow.tsx","Line.tsx","App.tsx","index.tsx"],"names":["growBox","box","size","x","y","w","h","isPointInBox","point","styles","stylesheet","arrow","position","top","right","pointerEvents","overflow","Arrow","arrowDescriptor","color","zIndex","sx","sy","c1x","c1y","c2x","c2y","ex","ey","ae","className","style","width","height","xmlns","d","stroke","strokeWidth","arrowHeadSize","fill","points","transform","Type","line","Line","x1","y1","x2","y2","App","useControls","type","value","BoxToBox","options","PointToPoint","label","showWhy","showArrow","padStart","min","max","step","padEnd","controlPointStretch","allowedStartSides","folder","canStartAtTop","canStartAtLeft","canStartAtBottom","canStartAtRight","allowedEndSides","canEndAtTop","canEndAtLeft","canEndAtBottom","canEndAtRight","useState","window","innerWidth","innerHeight","startBox","setStartBox","useEffect","onResize","console","log","b","addEventListener","removeEventListener","endBox","setEndBox","onMouseDown","useCallback","e","update","clientX","clientY","button","unlisten","onTouchStart","touches","length","push","pointToPointArrow","getArrow","boxToBoxArrow","getBoxToBoxArrow","startAtTop","startAtBottom","startAtLeft","startAtRight","endAtTop","endAtBottom","endAtLeft","endAtRight","startPoints","endPoints","p1","p2","lines","bestLine","shortestDistance","isStartEndUsable","start","end","startSideId","startPoint","endSideId","endPoint","distance","Math","sqrt","pow","isUsable","id","map","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.18bfabdf.chunk.js","sourcesContent":["export type RectSide = 'top' | 'right' | 'bottom' | 'left'\nexport type Vec2 = { x: number; y: number }\nexport type Box = {\n  x: number\n  y: number\n  w: number\n  h: number\n}\n\n/** Calculate the distance of two points. */\nexport function distanceOf(p1: Vec2, p2: Vec2): number {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2))\n}\n\n/**\n * @param box\n * @param size Add `size` to all edges.\n */\nexport function growBox(box: Box, size: number): Box {\n  return {\n    x: box.x - size,\n    y: box.y - size,\n    w: box.w + 2 * size,\n    h: box.h + 2 * size,\n  }\n}\n\nexport function isPointInBox(point: Vec2, box: Box): boolean {\n  return (\n    point.x > box.x &&\n    point.x < box.x + box.w &&\n    point.y > box.y &&\n    point.y < box.y + box.h\n  )\n}\n\n/** Calculate the control point. */\nexport function controlPointOf(\n  target: Vec2,\n  another: Vec2,\n  sideOfTarget: RectSide,\n  /**\n   * The distance a control point must be far away from the target in the\n   * direction of leaving the target.\n   */\n  minDistanceToTarget: number = 50\n) {\n  switch (sideOfTarget) {\n    case 'top': {\n      return {\n        x: target.x,\n        y: Math.min((target.y + another.y) / 2, target.y - minDistanceToTarget),\n      }\n    }\n    case 'bottom': {\n      return {\n        x: target.x,\n        y: Math.max((target.y + another.y) / 2, target.y + minDistanceToTarget),\n      }\n    }\n    case 'left': {\n      return {\n        x: Math.min((target.x + another.x) / 2, target.x - minDistanceToTarget),\n        y: target.y,\n      }\n    }\n    case 'right': {\n      return {\n        x: Math.max((target.x + another.x) / 2, target.x + minDistanceToTarget),\n        y: target.y,\n      }\n    }\n  }\n}\n\n/** Return the entering angle of a rectangle side. */\nexport function angleOf(enteringSide: RectSide): number {\n  switch (enteringSide) {\n    case 'left':\n      return 0\n    case 'top':\n      return 90\n    case 'right':\n      return 180\n    case 'bottom':\n      return 270\n  }\n}\n","import * as React from 'react'\nimport { stylesheet } from 'typestyle'\n\ninterface Props {\n  arrowDescriptor: number[]\n  color?: string\n  zIndex?: number\n}\n\nconst styles = stylesheet({\n  arrow: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    pointerEvents: 'none',\n    overflow: 'visible',\n  },\n})\n\nexport function Arrow({\n  arrowDescriptor,\n  color = 'black',\n  zIndex = 0,\n}: Props): JSX.Element {\n  const arrowHeadSize = 9\n  const [sx, sy, c1x, c1y, c2x, c2y, ex, ey, ae] = arrowDescriptor\n\n  return (\n    <svg\n      className={styles.arrow}\n      style={{ zIndex }}\n      width=\"100%\"\n      height=\"100%\"\n      xmlns=\"http://www.w3.org/2000/svg\">\n      <path\n        d={`M ${sx} ${sy} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${ex} ${ey}`}\n        stroke={color}\n        strokeWidth={arrowHeadSize / 2}\n        fill=\"none\"\n      />\n      <polygon\n        points={`0,${-arrowHeadSize} ${arrowHeadSize *\n          2},0, 0,${arrowHeadSize}`}\n        transform={`translate(${ex}, ${ey}) rotate(${ae})`}\n        fill={color}\n      />\n    </svg>\n  )\n}\n","import * as React from 'react'\nimport { stylesheet } from 'typestyle'\n\ninterface Props {\n  x1: number\n  y1: number\n  x2: number\n  y2: number\n  color?: string\n  strokeWidth?: number\n  zIndex?: number\n}\n\nconst styles = stylesheet({\n  line: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    pointerEvents: 'none',\n    overflow: 'visible',\n  },\n})\n\nexport function Line({\n  x1,\n  y1,\n  x2,\n  y2,\n  color = 'black',\n  strokeWidth = 3,\n  zIndex = 0,\n}: Props) {\n  return (\n    <svg\n      className={styles.line}\n      style={{ zIndex }}\n      width=\"100%\"\n      height=\"100%\"\n      xmlns=\"http://www.w3.org/2000/svg\">\n      <path\n        d={`M ${x1} ${y1} L ${x2} ${y2}`}\n        stroke={color}\n        strokeWidth={strokeWidth}\n        fill=\"none\"\n      />\n    </svg>\n  )\n}\n","import React, { useCallback, useEffect, useState } from 'react'\nimport { folder, useControls } from 'leva'\nimport { ArrowOptions, getArrow, getBoxToBoxArrow } from 'curved-arrows'\nimport {\n  RectSide,\n  distanceOf,\n  growBox,\n  isPointInBox,\n  Vec2,\n  Box,\n  /** create-react-app is unable to import from 'curved-arrows/src/utils' */\n} from './curved-arrows/utils'\nimport { Arrow } from './Arrow'\nimport { Line } from './Line'\n\nenum Type {\n  PointToPoint = 'Point to Point',\n  BoxToBox = 'Box to Box',\n}\n\nfunction App() {\n  /** Leva controls. */\n  const {\n    type,\n    showWhy,\n    showArrow,\n    padStart,\n    padEnd,\n    controlPointStretch,\n    canStartAtTop,\n    canStartAtLeft,\n    canStartAtBottom,\n    canStartAtRight,\n    canEndAtTop,\n    canEndAtLeft,\n    canEndAtBottom,\n    canEndAtRight,\n  } = useControls({\n    type: {\n      value: Type.BoxToBox,\n      options: [Type.BoxToBox, Type.PointToPoint],\n      label: 'Type',\n    },\n    showWhy: { value: false, label: 'Show Why' },\n    showArrow: { value: true, label: 'Show Arrow' },\n    padStart: { value: 0, min: -20, max: 20, step: 1 },\n    padEnd: { value: 9, min: -20, max: 20, step: 1 },\n    controlPointStretch: { value: 50, min: 0, max: 300 },\n    allowedStartSides: folder({\n      canStartAtTop: { value: true, label: 'top'},\n      canStartAtLeft: { value: true, label: 'left'},\n      canStartAtBottom: { value: true, label: 'bottom'},\n      canStartAtRight: { value: true, label: 'right'},\n    }),\n    allowedEndSides: folder({\n      canEndAtTop: { value: true, label: 'top'},\n      canEndAtLeft: { value: true, label: 'left'},\n      canEndAtBottom: { value: true, label: 'bottom'},\n      canEndAtRight: { value: true, label: 'right'},\n    })\n  })\n\n  /** Fixed start box. */\n  const [startBox, setStartBox] = useState({\n    x: window.innerWidth / 2 - 100,\n    y: window.innerHeight / 2 - 50,\n    w: 200,\n    h: 80,\n  })\n\n  /** Fix start box in the center. */\n  useEffect(() => {\n    function onResize() {\n      console.log('r')\n      setStartBox(b => ({\n        ...b,\n        x: window.innerWidth / 2 - b.w / 2,\n        y: window.innerHeight / 2 - b.h / 2,\n      }))\n    }\n\n    window.addEventListener('resize', onResize)\n\n    return () => window.removeEventListener('resize', onResize)\n  }, [])\n\n  /** Movable end box. */\n  const [endBox, setEndBox] = useState({\n    x: startBox.x + 270,\n    y: startBox.y + 70,\n    w: 180,\n    h: 80,\n  })\n\n  /** Handle mouse. */\n  const onMouseDown = useCallback((e: React.MouseEvent) => {\n    if (e.button !== 0) return\n\n    function update(e: React.MouseEvent | MouseEvent) {\n      setEndBox(b => ({ ...b, x: e.clientX - b.w / 2, y: e.clientY - b.h / 2 }))\n    }\n\n    function unlisten() {\n      window.removeEventListener('mousemove', update)\n      window.removeEventListener('mouseup', unlisten)\n    }\n\n    update(e)\n\n    window.addEventListener('mousemove', update)\n    window.addEventListener('mouseup', unlisten)\n  }, [])\n\n  /** Handle touch. */\n  const onTouchStart = useCallback((e: React.TouchEvent) => {\n    if (e.touches.length > 1) return\n\n    function update(e: React.TouchEvent | TouchEvent) {\n      setEndBox(b => ({\n        ...b,\n        x: e.touches[0].clientX - b.w / 2,\n        y: e.touches[0].clientY - b.h / 2,\n      }))\n    }\n\n    function unlisten() {\n      window.removeEventListener('touchmove', update)\n      window.removeEventListener('touchend', unlisten)\n      window.removeEventListener('touchcancel', unlisten)\n    }\n\n    update(e)\n\n    window.addEventListener('touchmove', update)\n    window.addEventListener('touchend', unlisten)\n    window.addEventListener('touchcancel', unlisten)\n  }, [])\n\n  const allowedStartSides: RectSide[] = [];\n  const allowedEndSides: RectSide[] = [];\n\n  if (canStartAtTop) { allowedStartSides.push('top') }\n  if (canStartAtLeft) { allowedStartSides.push('left') }\n  if (canStartAtBottom) { allowedStartSides.push('bottom') }\n  if (canStartAtRight) { allowedStartSides.push('right') }\n  if (canEndAtTop) { allowedEndSides.push('top') }\n  if (canEndAtLeft) { allowedEndSides.push('left') }\n  if (canEndAtBottom) { allowedEndSides.push('bottom') }\n  if (canEndAtRight) { allowedEndSides.push('right') }\n  \n  /** Get arrow data. */\n  const options: ArrowOptions = { padStart, padEnd, controlPointStretch, allowedStartSides, allowedEndSides }\n  const pointToPointArrow = getArrow(\n    startBox.x,\n    startBox.y,\n    endBox.x,\n    endBox.y,\n    options\n  )\n  const boxToBoxArrow = getBoxToBoxArrow(\n    startBox.x,\n    startBox.y,\n    startBox.w,\n    startBox.h,\n    endBox.x,\n    endBox.y,\n    endBox.w,\n    endBox.h,\n    options\n  )\n\n  /** For explanation part. */\n\n  /** Points of start box. */\n  const startAtTop = {\n    x: startBox.x + startBox.w / 2,\n    y: startBox.y - 2 * (options.padStart ?? 0),\n  }\n  const startAtBottom = {\n    x: startBox.x + startBox.w / 2,\n    y: startBox.y + startBox.h + 2 * (options.padStart ?? 0),\n  }\n  const startAtLeft = {\n    x: startBox.x - 2 * (options.padStart ?? 0),\n    y: startBox.y + startBox.h / 2,\n  }\n  const startAtRight = {\n    x: startBox.x + startBox.w + 2 * (options.padStart ?? 0),\n    y: startBox.y + startBox.h / 2,\n  }\n\n  /** Points of end box. */\n  const endAtTop = {\n    x: endBox.x + endBox.w / 2,\n    y: endBox.y - 2 * (options.padEnd ?? 0),\n  }\n  const endAtBottom = {\n    x: endBox.x + endBox.w / 2,\n    y: endBox.y + endBox.h + 2 * (options.padEnd ?? 0),\n  }\n  const endAtLeft = {\n    x: endBox.x - 2 * (options.padEnd ?? 0),\n    y: endBox.y + endBox.h / 2,\n  }\n  const endAtRight = {\n    x: endBox.x + endBox.w + 2 * (options.padEnd ?? 0),\n    y: endBox.y + endBox.h / 2,\n  }\n\n  type Coordinate = { x: number, y: number };\n\n  const startPoints: Coordinate[] = [];\n  const endPoints: Coordinate[] = []\n\n  if (canStartAtTop) { startPoints.push(startAtTop) };\n  if (canStartAtRight) { startPoints.push(startAtRight) };\n  if (canStartAtBottom) { startPoints.push(startAtBottom) };\n  if (canStartAtLeft) { startPoints.push(startAtLeft) };\n  if (canEndAtTop) { endPoints.push(endAtTop) };\n  if (canEndAtRight) { endPoints.push(endAtRight) };\n  if (canEndAtBottom) { endPoints.push(endAtBottom) };\n  if (canEndAtLeft) { endPoints.push(endAtLeft) };\n\n  if (startPoints.length === 0) {\n    startPoints.push(...[startAtTop, startAtRight, startAtBottom, startAtLeft,])\n  }\n\n  if (endPoints.length === 0) {\n    endPoints.push(...[endAtTop, endAtRight, endAtBottom, endAtLeft,])\n  }\n\n  const keepOutZone = 15\n  const lines: {\n    id: string\n    distance: number\n    start: Vec2\n    end: Vec2\n    isUsable: boolean\n  }[] = []\n  let bestLine = '0-0'\n  let shortestDistance = 1 / 0\n\n  function isStartEndUsable(\n    start: Vec2,\n    end: Vec2,\n    startBox: Box,\n    endBox: Box\n  ) {\n    return !(\n      isPointInBox(start, growBox(endBox, keepOutZone)) ||\n      isPointInBox(end, growBox(startBox, keepOutZone))\n    )\n  }\n\n  for (let startSideId = 0; startSideId < startPoints.length; startSideId++) {\n    const startPoint = startPoints[startSideId]\n\n    for (let endSideId = 0; endSideId < endPoints.length; endSideId++) {\n      const endPoint = endPoints[endSideId]\n\n      const distance = distanceOf(startPoint, endPoint)\n      const isUsable = isStartEndUsable(startPoint, endPoint, startBox, endBox)\n      const line = {\n        id: `${startSideId}-${endSideId}`,\n        distance,\n        start: startPoint,\n        end: endPoint,\n        isUsable,\n      }\n      lines.push(line)\n      if (isUsable && distance < shortestDistance) {\n        shortestDistance = distance\n        bestLine = line.id\n      }\n    }\n  }\n\n  return (\n    <div className=\"app\" onMouseDown={onMouseDown} onTouchStart={onTouchStart}>\n      {type === Type.BoxToBox && (\n        <>\n          <div\n            key=\"startBox\"\n            className=\"box\"\n            style={{\n              transform: `translate(${startBox.x}px, ${startBox.y}px)`,\n              width: startBox.w,\n              height: startBox.h,\n            }}\n          />\n          <div\n            key=\"endBox\"\n            className=\"box\"\n            style={{\n              transform: `translate(${endBox.x}px, ${endBox.y}px)`,\n              width: endBox.w,\n              height: endBox.h,\n            }}\n          />\n        </>\n      )}\n      <div>\n        {showWhy &&\n          lines.map(line => (\n            <Line\n              key={line.id}\n              x1={line.start.x}\n              y1={line.start.y}\n              x2={line.end.x}\n              y2={line.end.y}\n              color={\n                line.isUsable\n                  ? bestLine === line.id\n                    ? 'hsl(37deg, 87%, 68%)' // yellow\n                    : 'hsl(138deg, 83%, 79%)' // green\n                  : 'hsl(350deg, 100%, 77%)' // red\n              }\n              strokeWidth={bestLine === line.id ? 6 : 3}\n              zIndex={bestLine === line.id ? 1 : 0}\n            />\n          ))}\n      </div>\n      {showArrow && (\n        <Arrow\n          arrowDescriptor={\n            type === Type.BoxToBox ? boxToBoxArrow : pointToPointArrow\n          }\n          color=\"rgb(53, 47, 43)\"\n          zIndex={1}\n        />\n      )}\n    </div>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}