{"version":3,"sources":["curved-arrows/utils.ts","Arrow.tsx","Line.tsx","App.tsx","index.tsx"],"names":["growBox","box","size","x","y","w","h","isPointInBox","point","styles","stylesheet","arrow","position","top","right","pointerEvents","overflow","Arrow","arrowDescriptor","color","zIndex","sx","sy","c1x","c1y","c2x","c2y","ex","ey","ae","className","style","width","height","xmlns","d","stroke","strokeWidth","arrowHeadSize","fill","points","transform","Type","line","Line","x1","y1","x2","y2","App","useControls","type","value","BoxToBox","options","PointToPoint","label","showWhy","showArrow","padStart","min","max","step","padEnd","controlPointStretch","useState","window","innerWidth","innerHeight","startBox","setStartBox","useEffect","onResize","console","log","b","addEventListener","removeEventListener","p1","p2","endBox","setEndBox","onMouseDown","useCallback","e","update","clientX","clientY","button","unlisten","onTouchStart","touches","length","pointToPointArrow","getArrow","boxToBoxArrow","getBoxToBoxArrow","startAtTop","startAtBottom","startAtLeft","startAtRight","endAtTop","endAtBottom","endAtLeft","sides","startPoints","endPoints","lines","bestLine","shortestDistance","isStartEndUsable","start","end","startSideId","startPoint","endSideId","endPoint","distance","Math","sqrt","pow","isUsable","id","push","map","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.83d48375.chunk.js","sourcesContent":["export type RectSide = 'top' | 'right' | 'bottom' | 'left'\nexport type Vec2 = { x: number; y: number }\nexport type Box = {\n  x: number\n  y: number\n  w: number\n  h: number\n}\n\n/** Calculate the distance of two points. */\nexport function distanceOf(p1: Vec2, p2: Vec2): number {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2))\n}\n\n/**\n * @param box\n * @param size Add `size` to all edges.\n */\nexport function growBox(box: Box, size: number): Box {\n  return {\n    x: box.x - size,\n    y: box.y - size,\n    w: box.w + 2 * size,\n    h: box.h + 2 * size,\n  }\n}\n\nexport function isPointInBox(point: Vec2, box: Box): boolean {\n  return (\n    point.x > box.x &&\n    point.x < box.x + box.w &&\n    point.y > box.y &&\n    point.y < box.y + box.h\n  )\n}\n\n/** Calculate the control point. */\nexport function controlPointOf(\n  target: Vec2,\n  another: Vec2,\n  sideOfTarget: RectSide,\n  /**\n   * The distance a control point must be far away from the target in the\n   * direction of leaving the target.\n   */\n  minDistanceToTarget: number = 50\n) {\n  switch (sideOfTarget) {\n    case 'top': {\n      return {\n        x: target.x,\n        y: Math.min((target.y + another.y) / 2, target.y - minDistanceToTarget),\n      }\n    }\n    case 'bottom': {\n      return {\n        x: target.x,\n        y: Math.max((target.y + another.y) / 2, target.y + minDistanceToTarget),\n      }\n    }\n    case 'left': {\n      return {\n        x: Math.min((target.x + another.x) / 2, target.x - minDistanceToTarget),\n        y: target.y,\n      }\n    }\n    case 'right': {\n      return {\n        x: Math.max((target.x + another.x) / 2, target.x + minDistanceToTarget),\n        y: target.y,\n      }\n    }\n  }\n}\n\n/** Return the entering angle of a rectangle side. */\nexport function angleOf(enteringSide: RectSide): number {\n  switch (enteringSide) {\n    case 'left':\n      return 0\n    case 'top':\n      return 90\n    case 'right':\n      return 180\n    case 'bottom':\n      return 270\n  }\n}\n","import * as React from 'react'\nimport { stylesheet } from 'typestyle'\n\ninterface Props {\n  arrowDescriptor: number[]\n  color?: string\n  zIndex?: number\n}\n\nconst styles = stylesheet({\n  arrow: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    pointerEvents: 'none',\n    overflow: 'visible',\n  },\n})\n\nexport function Arrow({\n  arrowDescriptor,\n  color = 'black',\n  zIndex = 0,\n}: Props): JSX.Element {\n  const arrowHeadSize = 9\n  const [sx, sy, c1x, c1y, c2x, c2y, ex, ey, ae] = arrowDescriptor\n\n  return (\n    <svg\n      className={styles.arrow}\n      style={{ zIndex }}\n      width=\"100%\"\n      height=\"100%\"\n      xmlns=\"http://www.w3.org/2000/svg\">\n      <path\n        d={`M ${sx} ${sy} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${ex} ${ey}`}\n        stroke={color}\n        strokeWidth={arrowHeadSize / 2}\n        fill=\"none\"\n      />\n      <polygon\n        points={`0,${-arrowHeadSize} ${arrowHeadSize *\n          2},0, 0,${arrowHeadSize}`}\n        transform={`translate(${ex}, ${ey}) rotate(${ae})`}\n        fill={color}\n      />\n    </svg>\n  )\n}\n","import * as React from 'react'\nimport { stylesheet } from 'typestyle'\n\ninterface Props {\n  x1: number\n  y1: number\n  x2: number\n  y2: number\n  color?: string\n  strokeWidth?: number\n  zIndex?: number\n}\n\nconst styles = stylesheet({\n  line: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    pointerEvents: 'none',\n    overflow: 'visible',\n  },\n})\n\nexport function Line({\n  x1,\n  y1,\n  x2,\n  y2,\n  color = 'black',\n  strokeWidth = 3,\n  zIndex = 0,\n}: Props) {\n  return (\n    <svg\n      className={styles.line}\n      style={{ zIndex }}\n      width=\"100%\"\n      height=\"100%\"\n      xmlns=\"http://www.w3.org/2000/svg\">\n      <path\n        d={`M ${x1} ${y1} L ${x2} ${y2}`}\n        stroke={color}\n        strokeWidth={strokeWidth}\n        fill=\"none\"\n      />\n    </svg>\n  )\n}\n","import React, { useCallback, useEffect, useState } from 'react'\nimport { useControls } from 'leva'\nimport { getArrow, getBoxToBoxArrow } from 'curved-arrows'\nimport {\n  RectSide,\n  distanceOf,\n  growBox,\n  isPointInBox,\n  Vec2,\n  Box,\n  /** create-react-app is unable to import from 'curved-arrows/src/utils' */\n} from './curved-arrows/utils'\nimport { Arrow } from './Arrow'\nimport { Line } from './Line'\n\nenum Type {\n  PointToPoint = 'Point to Point',\n  BoxToBox = 'Box to Box',\n}\n\nfunction App() {\n  /** Leva controls. */\n  const {\n    type,\n    showWhy,\n    showArrow,\n    padStart,\n    padEnd,\n    controlPointStretch,\n  } = useControls({\n    type: {\n      value: Type.BoxToBox,\n      options: [Type.BoxToBox, Type.PointToPoint],\n      label: 'Type',\n    },\n    showWhy: { value: false, label: 'Show Why' },\n    showArrow: { value: true, label: 'Show Arrow' },\n    padStart: { value: 0, min: -20, max: 20, step: 1 },\n    padEnd: { value: 9, min: -20, max: 20, step: 1 },\n    controlPointStretch: { value: 50, min: 0, max: 300 },\n  })\n\n  /** Fixed start box. */\n  const [startBox, setStartBox] = useState({\n    x: window.innerWidth / 2 - 100,\n    y: window.innerHeight / 2 - 50,\n    w: 200,\n    h: 80,\n  })\n\n  /** Fix start box in the center. */\n  useEffect(() => {\n    function onResize() {\n      console.log('r')\n      setStartBox(b => ({\n        ...b,\n        x: window.innerWidth / 2 - b.w / 2,\n        y: window.innerHeight / 2 - b.h / 2,\n      }))\n    }\n\n    window.addEventListener('resize', onResize)\n\n    return () => window.removeEventListener('resize', onResize)\n  }, [])\n\n  /** Movable end box. */\n  const [endBox, setEndBox] = useState({\n    x: startBox.x + 270,\n    y: startBox.y + 70,\n    w: 180,\n    h: 80,\n  })\n\n  /** Handle mouse. */\n  const onMouseDown = useCallback((e: React.MouseEvent) => {\n    if (e.button !== 0) return\n\n    function update(e: React.MouseEvent | MouseEvent) {\n      setEndBox(b => ({ ...b, x: e.clientX - b.w / 2, y: e.clientY - b.h / 2 }))\n    }\n\n    function unlisten() {\n      window.removeEventListener('mousemove', update)\n      window.removeEventListener('mouseup', unlisten)\n    }\n\n    update(e)\n\n    window.addEventListener('mousemove', update)\n    window.addEventListener('mouseup', unlisten)\n  }, [])\n\n  /** Handle touch. */\n  const onTouchStart = useCallback((e: React.TouchEvent) => {\n    if (e.touches.length > 1) return\n\n    function update(e: React.TouchEvent | TouchEvent) {\n      setEndBox(b => ({\n        ...b,\n        x: e.touches[0].clientX - b.w / 2,\n        y: e.touches[0].clientY - b.h / 2,\n      }))\n    }\n\n    function unlisten() {\n      window.removeEventListener('touchmove', update)\n      window.removeEventListener('touchend', unlisten)\n      window.removeEventListener('touchcancel', unlisten)\n    }\n\n    update(e)\n\n    window.addEventListener('touchmove', update)\n    window.addEventListener('touchend', unlisten)\n    window.addEventListener('touchcancel', unlisten)\n  }, [])\n\n  /** Get arrow data. */\n  const options = { padStart, padEnd, controlPointStretch }\n  const pointToPointArrow = getArrow(\n    startBox.x,\n    startBox.y,\n    endBox.x,\n    endBox.y,\n    options\n  )\n  const boxToBoxArrow = getBoxToBoxArrow(\n    startBox.x,\n    startBox.y,\n    startBox.w,\n    startBox.h,\n    endBox.x,\n    endBox.y,\n    endBox.w,\n    endBox.h,\n    options\n  )\n\n  /** For explanation part. */\n\n  /** Points of start box. */\n  const startAtTop = {\n    x: startBox.x + startBox.w / 2,\n    y: startBox.y - 2 * options.padStart,\n  }\n  const startAtBottom = {\n    x: startBox.x + startBox.w / 2,\n    y: startBox.y + startBox.h + 2 * options.padStart,\n  }\n  const startAtLeft = {\n    x: startBox.x - 2 * options.padStart,\n    y: startBox.y + startBox.h / 2,\n  }\n  const startAtRight = {\n    x: startBox.x + startBox.w + 2 * options.padStart,\n    y: startBox.y + startBox.h / 2,\n  }\n\n  /** Points of end box. */\n  const endAtTop = {\n    x: endBox.x + endBox.w / 2,\n    y: endBox.y - 2 * options.padEnd,\n  }\n  const endAtBottom = {\n    x: endBox.x + endBox.w / 2,\n    y: endBox.y + endBox.h + 2 * options.padEnd,\n  }\n  const endAtLeft = {\n    x: endBox.x - 2 * options.padEnd,\n    y: endBox.y + endBox.h / 2,\n  }\n  const endAtRight = {\n    x: endBox.x + endBox.w + 2 * options.padEnd,\n    y: endBox.y + endBox.h / 2,\n  }\n\n  const sides: RectSide[] = ['top', 'right', 'bottom', 'left']\n  const startPoints = [startAtTop, startAtRight, startAtBottom, startAtLeft]\n  const endPoints = [endAtTop, endAtRight, endAtBottom, endAtLeft]\n\n  const keepOutZone = 15\n  const lines: {\n    id: string\n    distance: number\n    start: Vec2\n    end: Vec2\n    isUsable: boolean\n  }[] = []\n  let bestLine = '0-0'\n  let shortestDistance = 1 / 0\n\n  function isStartEndUsable(\n    start: Vec2,\n    end: Vec2,\n    startBox: Box,\n    endBox: Box\n  ) {\n    return !(\n      isPointInBox(start, growBox(endBox, keepOutZone)) ||\n      isPointInBox(end, growBox(startBox, keepOutZone))\n    )\n  }\n\n  for (let startSideId = 0; startSideId < sides.length; startSideId++) {\n    const startPoint = startPoints[startSideId]\n\n    for (let endSideId = 0; endSideId < sides.length; endSideId++) {\n      const endPoint = endPoints[endSideId]\n\n      const distance = distanceOf(startPoint, endPoint)\n      const isUsable = isStartEndUsable(startPoint, endPoint, startBox, endBox)\n      const line = {\n        id: `${startSideId}-${endSideId}`,\n        distance,\n        start: startPoint,\n        end: endPoint,\n        isUsable,\n      }\n      lines.push(line)\n      if (isUsable && distance < shortestDistance) {\n        shortestDistance = distance\n        bestLine = line.id\n      }\n    }\n  }\n\n  return (\n    <div className=\"app\" onMouseDown={onMouseDown} onTouchStart={onTouchStart}>\n      {type === Type.BoxToBox && (\n        <>\n          <div\n            key=\"startBox\"\n            className=\"box\"\n            style={{\n              transform: `translate(${startBox.x}px, ${startBox.y}px)`,\n              width: startBox.w,\n              height: startBox.h,\n            }}\n          />\n          <div\n            key=\"endBox\"\n            className=\"box\"\n            style={{\n              transform: `translate(${endBox.x}px, ${endBox.y}px)`,\n              width: endBox.w,\n              height: endBox.h,\n            }}\n          />\n        </>\n      )}\n      <div>\n        {showWhy &&\n          lines.map(line => (\n            <Line\n              key={line.id}\n              x1={line.start.x}\n              y1={line.start.y}\n              x2={line.end.x}\n              y2={line.end.y}\n              color={\n                line.isUsable\n                  ? bestLine === line.id\n                    ? 'hsl(37deg, 87%, 68%)' // yellow\n                    : 'hsl(138deg, 83%, 79%)' // green\n                  : 'hsl(350deg, 100%, 77%)' // red\n              }\n              strokeWidth={bestLine === line.id ? 6 : 3}\n              zIndex={bestLine === line.id ? 1 : 0}\n            />\n          ))}\n      </div>\n      {showArrow && (\n        <Arrow\n          arrowDescriptor={\n            type === Type.BoxToBox ? boxToBoxArrow : pointToPointArrow\n          }\n          color=\"rgb(53, 47, 43)\"\n          zIndex={1}\n        />\n      )}\n    </div>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}